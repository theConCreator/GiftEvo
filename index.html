<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Прыгающая Кирка - Minecraft Arcade</title>
    <style>
        /* CSS Стили для АДАПТИВНОСТИ */
        body {
            background-color: #282c34;
            color: #fff;
            font-family: 'Courier New', monospace;
            
            /* Используем Flexbox для центрирования и адаптации */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            
            /* Основное изменение: 100% высоты и предотвращение прокрутки */
            height: 100vh;
            margin: 0;
            overflow: hidden; 
            box-sizing: border-box; /* Важно для адаптивности */
            padding: 10px; /* Небольшой отступ по краям */
        }

        h1, p {
            margin: 5px 0;
            flex-shrink: 0; /* Гарантируем, что заголовки не сжимаются */
        }

        #game-container {
            display: flex;
            flex-direction: row;
            border: 5px solid #000;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            background-color: #444; 
            margin: 10px 0;
            
            /* Ограничиваем размер контейнера, чтобы он помещался в оставшееся место */
            max-width: 95vw;
            max-height: 80vh; /* Ограничиваем высоту, чтобы оставить место для заголовков и кнопки */
        }

        #info-panel {
            width: 150px; 
            background-color: #333;
            padding: 10px;
            text-align: left;
            border-right: 2px solid #000;
            font-size: 0.9em;
            flex-shrink: 0; /* Панель информации не сжимается */
        }

        #game-canvas {
            display: block; 
            background-color: #6d6d6d;
            /* Позволяем Canvas сжиматься/растягиваться в рамках его контейнера */
            width: auto;
            height: auto;
        }
        
        button {
            margin-top: 5px; 
            padding: 10px 20px; 
            font-size: 1.2em;
            cursor: pointer;
            flex-shrink: 0;
        }
    </style>
</head>
<body>

    <h1>⛏️ Прыгающая Кирка</h1>
    <p>Цель: набрать как можно больше алмазов, копая бесконечно!</p>

    <div id="game-container">
        <div id="info-panel">
            <h3>Ресурсы:</h3>
            <div class="resource-item"><div class="resource-color" style="background-color: #555555;"></div>Уголь: <span id="coal-count">0</span></div>
            <div class="resource-item"><div class="resource-color" style="background-color: #c7c7c7;"></div>Железо: <span id="iron-count">0</span></div>
            <div class="resource-item"><div class="resource-color" style="background-color: #ffcc00;"></div>Золото: <span id="gold-count">0</span></div>
            <div class="resource-item"><div class="resource-color" style="background-color: #66ffff;"></div>Алмазы: <span id="diamond-count">0</span></div>
            <p>Глубина: <span id="depth-count">0</span> м</p>
        </div>
        
        <canvas id="game-canvas"></canvas>
    </div>
    
    <button onclick="startGame()">Запустить Кирку!</button>

    <script>
        // JavaScript Логика Игры
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const button = document.querySelector('button');
        const depthDisplay = document.getElementById('depth-count');

        // --- Константы ---
        const BLOCK_SIZE = 40; 
        const GAME_WIDTH = 9; 
        const GAME_HEIGHT = 20; 
        
        // Физика
        const INITIAL_DROP_VELOCITY = 1; 
        const INITIAL_JUMP_VELOCITY = -8; 
        const GRAVITY = 0.3; 
        const HORIZONTAL_MOMENTUM = 2; 

        // Скроллинг
        const SCROLL_ROWS = 10; 
        const SCROLL_THRESHOLD = 8 * BLOCK_SIZE; 

        // Устанавливаем размер Canvas в JS, чтобы избежать проблем с масштабированием
        canvas.width = GAME_WIDTH * BLOCK_SIZE;
        canvas.height = GAME_HEIGHT * BLOCK_SIZE;

        // --- Типы Блоков ---
        const BLOCK_TYPES = {
            AIR: 0,
            STONE: 1,
            COAL: 2,
            IRON: 3,
            GOLD: 4,
            DIAMOND: 5,
            WALL: 9 
        };

        const BLOCK_COLORS = {
            [BLOCK_TYPES.STONE]: '#a0a0a0',
            [BLOCK_TYPES.COAL]: '#555555',
            [BLOCK_TYPES.IRON]: '#c7c7c7',
            [BLOCK_TYPES.GOLD]: '#ffcc00',
            [BLOCK_TYPES.DIAMOND]: '#66ffff',
            [BLOCK_TYPES.WALL]: '#363636'
        };

        // --- Состояние Игры ---
        let gameGrid = [];
        let currentDepth = 0; 
        let pickaxe = {
            x: GAME_WIDTH / 2 * BLOCK_SIZE, 
            y: 0, 
            vy: 0, 
            vx: 0,
            radius: BLOCK_SIZE / 2 
        };
        let resources = {
            [BLOCK_TYPES.COAL]: 0,
            [BLOCK_TYPES.IRON]: 0,
            [BLOCK_TYPES.GOLD]: 0,
            [BLOCK_TYPES.DIAMOND]: 0
        };
        let gameInterval = null;

        // --- Функции Инициализации и Генерации ---
        
        function generateNewChunk(chunkHeight) {
            const newChunk = [];
            for (let y = 0; y < chunkHeight; y++) {
                const row = [];
                for (let x = 0; x < GAME_WIDTH; x++) {
                    if (x === 0 || x === GAME_WIDTH - 1) {
                        row.push(BLOCK_TYPES.WALL);
                        continue;
                    }

                    const absoluteY = currentDepth + y; 
                    let type = BLOCK_TYPES.STONE;
                    const rand = Math.random();

                    if (absoluteY > 50 && rand < 0.02) type = BLOCK_TYPES.DIAMOND;
                    else if (absoluteY > 30 && rand < 0.07) type = BLOCK_TYPES.GOLD;
                    else if (absoluteY > 10 && rand < 0.15) type = BLOCK_TYPES.IRON;
                    else if (rand < 0.25) type = BLOCK_TYPES.COAL;
                    
                    row.push(type);
                }
                newChunk.push(row);
            }
            currentDepth += chunkHeight;
            return newChunk;
        }

        function generateInitialGrid() {
            gameGrid = [];
            currentDepth = 0;
            
            for(let y = 0; y < 3; y++) {
                gameGrid.push(new Array(GAME_WIDTH).fill(BLOCK_TYPES.AIR));
            }
            currentDepth = 3; 

            const INITIAL_GENERATION_HEIGHT = GAME_HEIGHT * 2;
            const chunk = generateNewChunk(INITIAL_GENERATION_HEIGHT);
            gameGrid = gameGrid.concat(chunk);
        }

        function resetPickaxe() {
            pickaxe.x = GAME_WIDTH / 2 * BLOCK_SIZE;
            pickaxe.y = pickaxe.radius; 
            pickaxe.vy = INITIAL_DROP_VELOCITY; 
            pickaxe.vx = 0;
        }

        function startGame() {
            if (gameInterval) clearInterval(gameInterval);
            
            generateInitialGrid(); 
            resetPickaxe();
            Object.keys(resources).forEach(key => resources[key] = 0);
            updateResourcesDisplay();
            
            button.disabled = true;
            button.innerText = "Кирка в работе...";
            
            gameInterval = setInterval(gameLoop, 1000 / 60); 
        }

        // --- Отрисовка ---

        function drawBlock(x, y, type) {
            if (type === BLOCK_TYPES.AIR) return;

            ctx.fillStyle = BLOCK_COLORS[type] || '#555';
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            ctx.strokeStyle = '#00000033'; 
            ctx.lineWidth = 1;
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            if (type !== BLOCK_TYPES.STONE && type !== BLOCK_TYPES.WALL) {
                ctx.fillStyle = 'black';
                for (let i = 0; i < 4; i++) {
                    const px = x * BLOCK_SIZE + Math.floor(Math.random() * BLOCK_SIZE);
                    const py = y * BLOCK_SIZE + Math.floor(Math.random() * BLOCK_SIZE);
                    ctx.fillRect(px, py, 2, 2);
                }
            }
        }

        function drawPickaxe() {
            const S = BLOCK_SIZE / 16; 
            const centerX = pickaxe.x;
            const centerY = pickaxe.y;
            const x = centerX - 10 * S; 
            const y = centerY - 10 * S; 

            const BLADE_COLOR = '#a0a0a0'; 
            const STICK_COLOR = '#964b00';

            const pixelArt = [
                {c: STICK_COLOR, x: 12, y: 12, w: 2, h: 4},
                {c: STICK_COLOR, x: 10, y: 0, w: 2, h: 12},
                {c: BLADE_COLOR, x: 0, y: 8, w: 10, h: 2}, 
                {c: BLADE_COLOR, x: 8, y: 6, w: 2, h: 2}, 
                {c: BLADE_COLOR, x: 10, y: 10, w: 2, h: 2},
            ];
            
            ctx.strokeStyle = '#00000088'; 
            ctx.lineWidth = 1;

            pixelArt.forEach(p => {
                ctx.fillStyle = p.c;
                ctx.fillRect(x + p.x * S, y + p.y * S, p.w * S, p.h * S);
            });
            
            ctx.strokeRect(x + 10 * S, y, 2 * S, 12 * S);
            ctx.strokeRect(x, y + 8 * S, 10 * S, 2 * S);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < GAME_HEIGHT; y++) {
                for (let x = 0; x < GAME_WIDTH; x++) {
                    if(gameGrid[y]) {
                         drawBlock(x, y, gameGrid[y][x]);
                    }
                }
            }

            drawPickaxe();
        }

        // --- Игровая Логика ---

        function updateResourcesDisplay() {
            document.getElementById('coal-count').innerText = resources[BLOCK_TYPES.COAL];
            document.getElementById('iron-count').innerText = resources[BLOCK_TYPES.IRON];
            document.getElementById('gold-count').innerText = resources[BLOCK_TYPES.GOLD];
            document.getElementById('diamond-count').innerText = resources[BLOCK_TYPES.DIAMOND];
            // Используем Math.max для отображения глубины, чтобы не показывать 0 в начале
            depthDisplay.innerText = Math.max(0, currentDepth - GAME_HEIGHT).toFixed(0); 
        }

        function update() {
            // 1. Применяем гравитацию
            pickaxe.vy += GRAVITY;

            // 2. Обновление позиции
            pickaxe.y += pickaxe.vy; 
            pickaxe.x += pickaxe.vx;
            
            // 3. Проверка границ по горизонтали (стены)
            // Столкновение со стеной должно происходить до ее центра
            const WALL_COLLISION_X_MIN = BLOCK_SIZE + pickaxe.radius;
            const WALL_COLLISION_X_MAX = canvas.width - (BLOCK_SIZE + pickaxe.radius);
            
            if (pickaxe.x <= WALL_COLLISION_X_MIN || pickaxe.x >= WALL_COLLISION_X_MAX) {
                pickaxe.vx *= -1;
                // Скорректируем позицию
                pickaxe.x = Math.max(WALL_COLLISION_X_MIN, Math.min(WALL_COLLISION_X_MAX, pickaxe.x));
            }

            // 4. Проверка границ по вертикали (Потолок)
            if (pickaxe.y <= pickaxe.radius) {
                pickaxe.vy = Math.abs(pickaxe.vy); 
                pickaxe.y = pickaxe.radius;
            }
            
            // 5. Проверка столкновений с блоками
            const gridX = Math.floor(pickaxe.x / BLOCK_SIZE);
            const gridY = Math.floor(pickaxe.y / BLOCK_SIZE);

            if (gridY >= 0 && gridY < GAME_HEIGHT && gridX >= 0 && gridX < GAME_WIDTH) {
                const blockType = gameGrid[gridY] ? gameGrid[gridY][gridX] : BLOCK_TYPES.AIR;

                if (blockType !== BLOCK_TYPES.AIR && blockType !== BLOCK_TYPES.WALL) {
                    
                    if (resources[blockType] !== undefined) {
                        resources[blockType]++;
                        updateResourcesDisplay();
                    }

                    gameGrid[gridY][gridX] = BLOCK_TYPES.AIR;
                    
                    pickaxe.vy = INITIAL_JUMP_VELOCITY; 
                    
                    const jumpDirection = Math.random() < 0.5 ? -1 : 1;
                    pickaxe.vx += jumpDirection * HORIZONTAL_MOMENTUM * Math.random(); 
                    pickaxe.vx = Math.max(-10, Math.min(10, pickaxe.vx)); 
                }
            }
            
            // 6. Реализация бесконечной прокрутки вниз
            if (pickaxe.y > SCROLL_THRESHOLD) {
                const scrollAmount = SCROLL_ROWS * BLOCK_SIZE;
                
                pickaxe.y -= scrollAmount;
                
                gameGrid.splice(0, SCROLL_ROWS); 
                
                const newRows = generateNewChunk(SCROLL_ROWS);
                gameGrid = gameGrid.concat(newRows);

                updateResourcesDisplay();
            }

            // 7. Завершение игры
            if (pickaxe.y > canvas.height + pickaxe.radius * 2) {
                clearInterval(gameInterval);
                gameInterval = null;
                button.disabled = false;
                button.innerText = "Игра окончена! Запустить снова.";
                alert(`Кирка упала! Достигнутая глубина: ${currentDepth} м. Ваши алмазы: ${resources[BLOCK_TYPES.DIAMOND]}`);
                return;
            }
        }

        function gameLoop() {
            update();
            draw();
        }

        // Инициализация при загрузке страницы
        generateInitialGrid();
        updateResourcesDisplay();
        draw(); 
    </script>

</body>
</html>