<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Mountain Drop — Long Map</title>
<style>
  html, body {
    margin:0;
    padding:0;
    overflow:hidden;
    width:100%;
    height:100%;
    font-family:Inter, sans-serif;
    background:linear-gradient(180deg,#071228,#0b1b33);
    color:#e6eef6;
  }
  #gameContainer {
    display:flex;
    width:100%;
    height:100%;
    position:relative;
  }
  #ui {
    position:absolute;
    top:16px;
    left:16px;
    background:rgba(0,0,0,0.2);
    padding:12px;
    border-radius:10px;
    backdrop-filter:blur(6px);
    z-index:10;
  }
  #ui button{
    margin:2px;
    padding:6px 10px;
    border:none;
    border-radius:6px;
    background:#7dd3fc;
    color:#06202a;
    font-weight:600;
    cursor:pointer;
  }
  #ui .player{
    display:flex;
    justify-content:space-between;
    margin:2px 0;
    font-size:13px;
  }
  canvas{
    display:block;
    background:linear-gradient(180deg,#071228,#0b1b33);
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>
  <div id="ui">
    <div>
      <button id="buyBtn">Купить шар</button>
      <button id="startBtn">Старт</button>
      <button id="regenBtn">Новая гора</button>
    </div>
    <div style="margin-top:8px;">
      <strong>Игроки:</strong>
      <div id="players"></div>
    </div>
    <div style="margin-top:8px;">
      <strong>Шары в очереди:</strong> <span id="queued">0</span><br>
      <strong>Общий счёт:</strong> <span id="totalScore">0</span>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let W = window.innerWidth;
  let H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;

  // --- UI ---
  const buyBtn = document.getElementById('buyBtn');
  const startBtn = document.getElementById('startBtn');
  const regenBtn = document.getElementById('regenBtn');
  const playersEl = document.getElementById('players');
  const queuedEl = document.getElementById('queued');
  const totalScoreEl = document.getElementById('totalScore');

  // --- World ---
  let terrain = null;
  let balls = [];
  let queued = [];
  let players = [];
  let totalScore = 0;

  const GRAVITY = 1200;
  const BALL_RADIUS = 12;
  const BALL_MASS = 1;
  const RESTITUTION = 0.15;
  const FRICTION_GROUND = 0.995;
  const AIR_FRICTION = 0.999;
  const SUBSTEPS = 3;
  const ROUND_BUY_SECONDS = 10;
  const MAX_SIM_SECONDS = 40;

  // Map size
  const MAP_WIDTH = 8000;
  const MAP_HEIGHT = 2000;

  // Camera
  let camX = 0, camY = 0, camZoom = 1;
  let targetCamX = 0, targetCamY = 0, targetZoom = 1;

  // Drag
  let isDragging = false, dragStartX = 0, dragStartY = 0, camStartX = 0, camStartY = 0;

  // Ball ID / Player ID
  let _ballId = 1;
  let _playerId = 1;

  function rand(min,max){return Math.random()*(max-min)+min;}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function dist(ax,ay,bx,by){const dx=ax-bx,dy=ay-by;return Math.sqrt(dx*dx+dy*dy);}
  function randomColor(){return `hsl(${rand(180,280)} 80% 60%)`;}

  function addPlayer(name){
    const p = {id:'p'+(_playerId++), name:name||('Player '+_playerId), score:0, color:randomColor()};
    players.push(p);
    renderPlayers();
    return p;
  }
  function renderPlayers(){
    playersEl.innerHTML='';
    players.forEach(p=>{
      const div = document.createElement('div');
      div.className='player';
      div.innerHTML=`<span style="color:${p.color}">${p.name}</span> <span>${p.score}</span>`;
      playersEl.appendChild(div);
    });
  }

  function generateTerrain(){
    const points=[];
    const N = 25;
    const marginTop = 50;
    const marginBottom = 100;
    const dx = MAP_WIDTH / N;
    let lastY = rand(marginTop, MAP_HEIGHT*0.3);
    for(let i=0;i<=N;i++){
      let x = i*dx;
      let slopeDeg = rand(-95,-50);
      let slopeRad = slopeDeg*Math.PI/180;
      let dy = Math.tan(-slopeRad)*dx;
      let y = clamp(lastY+dy, marginTop, MAP_HEIGHT-marginBottom);
      points.push({x,y});
      lastY = y;
    }
    const segments=[];
    for(let i=0;i<points.length-1;i++){
      const a=points[i], b=points[i+1];
      const dx=b.x-a.x, dy=b.y-a.y;
      const len=Math.hypot(dx,dy)||1;
      const nx=-dy/len, ny=dx/len;
      segments.push({a,b,dx,dy,len,nx,ny});
    }
    return {points,segments};
  }

  function spawnBalls(){
    const spacing = BALL_RADIUS*2.5;
    for(let i=0;i<queued.length;i++){
      const owner=queued[i];
      const x = terrain.points[0].x + i*spacing;
      const y = terrain.points[0].y - 40 - i*4;
      balls.push({id:'b'+(_ballId++), x,y,vx:0,vy:0,r:BALL_RADIUS,mass:BALL_MASS,owner:owner,active:true,scored:false});
    }
    queued=[];
    updateUI();
  }

  function updateUI(){
    queuedEl.textContent = queued.length;
    totalScoreEl.textContent = totalScore;
    renderPlayers();
  }

  // Physics
  function stepPhysics(dt){
    const invMass = 1/BALL_MASS;
    const subDt = dt/SUBSTEPS;
    for(let s=0;s<SUBSTEPS;s++){
      for(const b of balls){
        if(!b.active) continue;
        b.vy+=GRAVITY*subDt;
        b.vx*=AIR_FRICTION;
        b.vy*=AIR_FRICTION;
        b.x+=b.vx*subDt;
        b.y+=b.vy*subDt;
      }
      // collisions with terrain
      for(const seg of terrain.segments){
        for(const b of balls){
          if(!b.active) continue;
          const ax=seg.a.x, ay=seg.a.y;
          const bx=seg.b.x, by=seg.b.y;
          const vx=b.x-ax, vy=b.y-ay;
          const segLen2=seg.dx*seg.dx+seg.dy*seg.dy;
          let t=0;
          if(segLen2>0){ t=clamp((vx*seg.dx+vy*seg.dy)/segLen2,0,1);}
          const projX=ax+seg.dx*t;
          const projY=ay+seg.dy*t;
          const nx=b.x-projX, ny=b.y-projY;
          const d2=nx*nx+ny*ny;
          const r=b.r;
          if(d2<r*r-0.5){
            const d=Math.sqrt(Math.max(1e-6,d2));
            const pen=r-d;
            const nxu=nx/d, nyu=ny/d;
            b.x+=nxu*pen;
            b.y+=nyu*pen;
            const relVelN=b.vx*nxu+b.vy*nyu;
            const vn=-(1+RESTITUTION)*relVelN;
            b.vx+=vn*nxu;
            b.vy+=vn*nyu;
            const tx=-nyu, ty=nxu;
            const relVelT=b.vx*tx+b.vy*ty;
            const newRelT=relVelT*FRICTION_GROUND;
            const dvT=newRelT-relVelT;
            b.vx+=dvT*tx;
            b.vy+=dvT*ty;
          }
        }
      }
      // ball-ball collisions
      for(let i=0;i<balls.length;i++){
        const A=balls[i]; if(!A.active) continue;
        for(let j=i+1;j<balls.length;j++){
          const B=balls[j]; if(!B.active) continue;
          const dx=B.x-A.x, dy=B.y-A.y;
          const d2=dx*dx+dy*dy;
          const rsum=A.r+B.r;
          if(d2<rsum*rsum && d2>0){
            const d=Math.sqrt(d2);
            const nx=dx/d, ny=dy/d;
            const pen=rsum-d;
            const push=0.5*pen+1e-3;
            A.x-=nx*push; A.y-=ny*push;
            B.x+=nx*push; B.y+=ny*push;
            const rvx=B.vx-A.vx, rvy=B.vy-A.vy;
            const relN=rvx*nx+rvy*ny;
            if(relN>0) continue;
            const e=0.3;
            const jimp=-(1+e)*relN/(invMass+invMass);
            const jx=jimp*nx, jy=jimp*ny;
            A.vx-=jx*invMass; A.vy-=jy*invMass;
            B.vx+=jx*invMass; B.vy+=jy*invMass;
          }
        }
      }
    }
  }

  // Camera update
  function updateCamera(dt){
    // target: most advanced ball
    const activeBalls=balls.filter(b=>b.active);
    if(activeBalls.length>0){
      let lead=activeBalls.reduce((a,b)=>b.x>a.x?b:a);
      targetCamX=lead.x-W/2;
      targetCamY=lead.y-H/2;
      const speed=Math.hypot(lead.vx,lead.vy);
      targetZoom=clamp(1-0.0002*speed,0.5,1);
    } else {
      targetCamX=0; targetCamY=0; targetZoom=1;
    }
    // lerp
    camX+=(targetCamX-camX)*dt*3;
    camY+=(targetCamY-camY)*dt*3;
    camZoom+=(targetZoom-camZoom)*dt*3;
  }

  // Draw
  function render(){
    ctx.save();
    ctx.clearRect(0,0,W,H);
    ctx.translate(-camX,-camY);
    ctx.scale(camZoom,camZoom);

    // Terrain
    ctx.beginPath();
    const pts=terrain.points;
    ctx.moveTo(pts[0].x,pts[0].y);
    for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x,pts[i].y);
    ctx.strokeStyle='#7dd3fc';
    ctx.lineWidth=4;
    ctx.stroke();

    // Balls
    for(const b of balls){
      ctx.beginPath();
      ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
      ctx.fillStyle=b.owner?b.owner.color:'#7dd3fc';
      ctx.fill();
      ctx.lineWidth=2;
      ctx.strokeStyle='rgba(255,255,255,0.1)';
      ctx.stroke();
    }
    ctx.restore();
  }

  let lastTime = performance.now();
  function loop(now){
    const dt=(now-lastTime)/1000;
    lastTime=now;
    stepPhysics(dt);
    updateCamera(dt);
    render();
    requestAnimationFrame(loop);
  }

  function resetWorld(){
    terrain=generateTerrain();
    balls=[];
    queued=[];
    totalScore=0;
    players.forEach(p=>p.score=0);
    updateUI();
  }

  // --- UI actions ---
  buyBtn.addEventListener('click',()=>{
    if(players.length===0){addPlayer('Player1');}
    const owner=players[Math.floor(Math.random()*players.length)];
    queued.push(owner);
    updateUI();
  });
  startBtn.addEventListener('click',()=>{
    spawnBalls();
  });
  regenBtn.addEventListener('click',()=>{
    resetWorld();
  });

  // Drag camera
  canvas.addEventListener('mousedown',e=>{
    isDragging=true;
    dragStartX=e.clientX; dragStartY=e.clientY;
    camStartX=camX; camStartY=camY;
  });
  window.addEventListener('mousemove',e=>{
    if(isDragging){
      camX=camStartX-(e.clientX-dragStartX)/camZoom;
      camY=camStartY-(e.clientY-dragStartY)/camZoom;
    }
  });
  window.addEventListener('mouseup',()=>{isDragging=false;});
  canvas.addEventListener('touchstart',e=>{
    isDragging=true;
    dragStartX=e.touches[0].clientX; dragStartY=e.touches[0].clientY;
    camStartX=camX; camStartY=camY;
  });
  canvas.addEventListener('touchmove',e=>{
    if(isDragging){
      camX=camStartX-(e.touches[0].clientX-dragStartX)/camZoom;
      camY=camStartY-(e.touches[0].clientY-dragStartY)/camZoom;
    }
  });
  canvas.addEventListener('touchend',()=>{isDragging=false;});

  // Init
  addPlayer('Alice');
  addPlayer('Bob');
  resetWorld();
  loop(performance.now());

})();
</script>
</body>
</html>
