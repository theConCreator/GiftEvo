<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Balloon Arena — Улучшенный прототип</title>
<style>
:root{
  --bg1:#071025; --bg2:#081733; --glass: rgba(255,255,255,0.03);
  --accent:#5ec0ff; --danger:#ff6b6b;
  font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial;
}
*{box-sizing:border-box; user-select:none; -webkit-tap-highlight-color: transparent;}
body,html{margin:0;padding:0;height:100%;width:100%;display:flex;justify-content:center;align-items:center;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:#e6f3ff;}
.app{display:flex; flex-direction:column; gap:16px; width:400px; height:800px;}
#arena{position:relative; width:100%; height:600px; background:linear-gradient(180deg,#071022,#051223); border-radius:12px; overflow:hidden; border:1px solid rgba(255,255,255,0.03);}
.balloon{position:absolute;border-radius:50%;display:flex;align-items:center;justify-content:center;cursor:grab;touch-action:none;box-shadow:0 5px 15px rgba(0,0,0,0.4);}
.balloon:active{cursor:grabbing;}
.balloon .label{font-weight:800;font-size:12px;color:#fff;pointer-events:none;}
.burst{position:absolute;border-radius:50%;pointer-events:none;transform:translate(-50%,-50%);}
@keyframes burstAnim{0%{transform:translate(-50%,-50%) scale(0.2);opacity:1}50%{transform:translate(-50%,-50%) scale(1.6);opacity:0.9}100%{transform:translate(-50%,-50%) scale(3);opacity:0}}
.wall,.spike{position:absolute;}
.wall-line{background:#5ec0ff;}
.spike-line{background:#ff6b6b;}
.panel{background:var(--glass);border-radius:12px;padding:12px;overflow:hidden;box-shadow:0 10px 40px rgba(2,6,23,.6);}
.btn{background:linear-gradient(180deg,#16325a,#0f2746);padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);cursor:pointer;color:#e9f6ff;font-weight:700;margin-top:6px;width:100%;}
.wind-indicator{background:rgba(255,255,255,0.06);padding:6px 10px;border-radius:8px;font-size:13px; margin-top:6px;}
.results{height:100px; overflow-y:auto; font-size:13px; background:rgba(255,255,255,0.04); padding:8px; border-radius:6px; margin-top:6px;}
</style>
</head>
<body>
<div class="app">
  <div class="panel" style="display:flex;justify-content:space-between;align-items:center;">
    <div>Зажми чтобы создать шар; удерживай — надувай и перетаскивай; отпусти — шар улетит.</div>
    <div id="roundInfo">Раунд: 30</div>
  </div>
  <div id="arena"></div>
  <div class="panel" style="display:flex;flex-direction:column;">
    <div>Баланс: <b id="balance">1000</b></div>
    <button id="buyBtn" class="btn">Купить шар (10)</button>
    <button id="cashBtn" class="btn" disabled>Забрать</button>
    <div class="wind-indicator" id="windIndicator">Ветер: 0,0</div>
    <div id="results" class="results"></div>
  </div>
</div>

<script>
const CFG={
  price:10, roundTime:30, minR:18, maxR:220, inflatePerSec:28,
  popBase:0.005, popR:0.0015, friction:0.992, bounce:0.86,
  tick:16, windChange:6000, gridSize:10, wallWidth:4
};

let state={
  balance:1000, balloons:new Map(), nextId:1,
  selectedBalloonId:null, wind:{x:0,y:0}, walls:[], spikes:[]
};

const arena=document.getElementById('arena'),
      balanceEl=document.getElementById('balance'),
      buyBtn=document.getElementById('buyBtn'),
      cashBtn=document.getElementById('cashBtn'),
      resultsEl=document.getElementById('results'),
      roundInfo=document.getElementById('roundInfo'),
      windIndicator=document.getElementById('windIndicator');

function save(){localStorage.setItem('bb_balance',state.balance);}
function log(msg){resultsEl.insertAdjacentHTML('afterbegin',`<div>${msg}</div>`);}
function refresh(){
  balanceEl.textContent=state.balance.toFixed(2);
  cashBtn.disabled=!state.selectedBalloonId;
  roundInfo.textContent=`Раунд: ${Math.ceil(roundCounter)}`;
  windIndicator.textContent=`Ветер: ${state.wind.x.toFixed(1)}, ${state.wind.y.toFixed(1)}`;
}

// Создание шаров
function createBalloon(x,y,price){
  const id=state.nextId++;
  const el=document.createElement('div'); el.className='balloon'; el.dataset.id=id;
  el.style.left=(x-CFG.minR)+'px'; el.style.top=(y-CFG.minR)+'px';
  el.style.width=CFG.minR*2+'px'; el.style.height=CFG.minR*2+'px';
  el.style.background=`hsl(${Math.floor(Math.random()*360)},90%,55%)`;
  const label=document.createElement('div'); label.className='label'; label.textContent='x1.00'; el.appendChild(label);
  arena.appendChild(el);
  let obj={
    id, el, x, y, vx:0, vy:0, radius:CFG.minR, price,
    inflatedMs:0, lastInflate:null, popping:false, state:'idle',
    multiplier:1, dragging:false, lastPointer:null, recentVel:{x:0,y:0}
  };
  let pointerId=null;

  el.addEventListener('pointerdown', e=>{
    if(obj.popping) return;
    el.setPointerCapture(e.pointerId);
    pointerId=e.pointerId;
    obj.dragging=true; obj.state='inflating'; obj.lastInflate=performance.now();
    state.selectedBalloonId=obj.id; obj.lastPointer={x:e.clientX,y:e.clientY,t:performance.now()};
    refresh(); e.preventDefault();
  });

  window.addEventListener('pointermove', e=>{
    if(!obj.dragging||e.pointerId!==pointerId) return;
    const rect=arena.getBoundingClientRect();
    obj.x=e.clientX-rect.left; obj.y=e.clientY-rect.top;
    const now=performance.now(), dt=Math.max(1, now-obj.lastPointer.t);
    const dx=e.clientX-obj.lastPointer.x, dy=e.clientY-obj.lastPointer.y;
    obj.recentVel={x:dx/dt*1000, y:dy/dt*1000}; obj.lastPointer={x:e.clientX,y:e.clientY,t:now};
  });

  window.addEventListener('pointerup', e=>{
    if(e.pointerId!==pointerId) return;
    el.releasePointerCapture(e.pointerId);
    pointerId=null; obj.dragging=false; obj.state='idle';
    obj.vx=obj.recentVel.x*0.008; obj.vy=obj.recentVel.y*0.008;
    state.selectedBalloonId=obj.id; refresh();
  });

  state.balloons.set(id,obj); log(`Шар ${id} создан`);
  return obj;
}

function popBalloon(obj){
  if(obj.popping) return; obj.popping=true;
  const burst=document.createElement('div'); burst.className='burst';
  burst.style.left=obj.x+'px'; burst.style.top=obj.y+'px';
  burst.style.width=obj.radius*2+'px'; burst.style.height=obj.radius*2+'px';
  burst.style.background=`radial-gradient(circle, rgba(255,255,255,0.9), rgba(255,255,255,0.1))`;
  burst.style.animation='burstAnim .6s cubic-bezier(.2,.8,.2,1) forwards';
  arena.appendChild(burst); try{obj.el.remove()}catch{}; setTimeout(()=>{try{burst.remove()}catch{}},600);
  state.balloons.delete(obj.id); if(state.selectedBalloonId===obj.id) state.selectedBalloonId=null;
  log(`Шар ${obj.id} лопнул x${obj.multiplier.toFixed(2)}`);
}

function cashSelected(){
  const id=state.selectedBalloonId; if(!id) return;
  const obj=state.balloons.get(id); if(!obj||obj.popping) return;
  const payout=obj.price*obj.multiplier; state.balance+=payout; save();
  log(`Шар ${id} забран x${obj.multiplier.toFixed(2)} → ${payout.toFixed(2)}`);
  popBalloon(obj);
}

// Покупка шара — пользователь ставит его сам
buyBtn.addEventListener('click', ()=>{
  if(state.balance<CFG.price){log('Недостаточно средств'); return;}
  state.balance-=CFG.price; save();
  log('Нажмите и удерживайте на поле, чтобы создать шар.');
});

// Сетка стен и шипов (линии)
function generateWalls(){
  state.walls.forEach(w=>{try{w.el.remove()}catch{}}); state.spikes.forEach(s=>{try{s.el.remove()}catch{}});
  state.walls=[]; state.spikes=[];
  const stepX=arena.clientWidth/CFG.gridSize;
  const stepY=arena.clientHeight/CFG.gridSize;

  for(let i=0;i<=CFG.gridSize;i++){
    // Вертикальные линии
    if(Math.random()<0.08){
      const el=document.createElement('div'); el.className='wall-line';
      el.style.position='absolute'; el.style.left=i*stepX+'px'; el.style.top='0px';
      el.style.width=CFG.wallWidth+'px'; el.style.height=arena.clientHeight+'px';
      arena.appendChild(el); state.walls.push({x:i*stepX, y:0, w:CFG.wallWidth, h:arena.clientHeight});
    }
    // Горизонтальные линии
    if(Math.random()<0.08){
      const el=document.createElement('div'); el.className='spike-line';
      el.style.position='absolute'; el.style.top=i*stepY+'px'; el.style.left='0px';
      el.style.height=CFG.wallWidth+'px'; el.style.width=arena.clientWidth+'px';
      arena.appendChild(el); state.spikes.push({x:0, y:i*stepY, w:arena.clientWidth, h:CFG.wallWidth});
    }
  }
}
generateWalls();

// Ветер слабый
setInterval(()=>{
  state.wind.x=(Math.random()-0.5)*10; state.wind.y=(Math.random()-0.5)*10; refresh();
}, CFG.windChange);

// Основной цикл
let lastFrame=performance.now(); let roundCounter=CFG.roundTime;
function tick(now){
  const dt=Math.min(60, now-lastFrame); lastFrame=now; const sec=dt/1000;
  const W=arena.clientWidth, H=arena.clientHeight;
  const arr=Array.from(state.balloons.values());

  // Надувание и самопроизвольное лопание
  arr.forEach(obj=>{
    if(obj.state==='inflating') obj.radius=Math.min(CFG.maxR, obj.radius+CFG.inflatePerSec*sec);
    obj.multiplier=1+Math.pow(1+0.012*obj.radius,1.02)-1;
    if(!obj.popping){const chance=1-Math.exp(-(CFG.popBase+obj.radius*CFG.popR)*sec); if(Math.random()<chance) popBalloon(obj);}
  });

  // Движение и столкновения с границами
  arr.forEach(A=>{
    if(A.popping||A.dragging) return;
    A.vx+=state.wind.x*sec; A.vy+=state.wind.y*sec; A.x+=A.vx*dt; A.y+=A.vy*dt;

    // Границы
    if(A.x-A.radius<0){A.x=A.radius; A.vx=-A.vx*CFG.bounce;}
    if(A.x+A.radius>W){A.x=W-A.radius; A.vx=-A.vx*CFG.bounce;}
    if(A.y-A.radius<0){A.y=A.radius; A.vy=-A.vy*CFG.bounce;}
    if(A.y+A.radius>H){A.y=H-A.radius; A.vy=-A.vy*CFG.bounce;}
    A.vx*=Math.pow(CFG.friction, dt/16); A.vy*=Math.pow(CFG.friction, dt/16);
  });

  // Коллизия между шарами
  for(let i=0;i<arr.length;i++){
    const A=arr[i]; if(A.popping) continue;
    for(let j=i+1;j<arr.length;j++){
      const B=arr[j]; if(B.popping) continue;
      const dx=B.x-A.x, dy=B.y-A.y, dist=Math.hypot(dx,dy), minD=A.radius+B.radius;
      if(dist>0 && dist<minD){
        const overlap=minD-dist, nx=dx/dist, ny=dy/dist;
        const totalMass=A.radius*A.radius+B.radius*B.radius;
        A.x-=nx*overlap*(B.radius*B.radius/totalMass); A.y-=ny*overlap*(B.radius*B.radius/totalMass);
        B.x+=nx*overlap*(A.radius*A.radius/totalMass); B.y+=ny*overlap*(A.radius*A.radius/totalMass);
        const dvx=B.vx-A.vx, dvy=B.vy-A.vy, impact=dvx*nx+dvy*ny;
        if(impact>0){const impulse=impact*0.9; A.vx+=nx*impulse*(B.radius*B.radius/totalMass); A.vy+=ny*impulse*(B.radius*B.radius/totalMass); B.vx-=nx*impulse*(A.radius*A.radius/totalMass); B.vy-=ny*impulse*(A.radius*A.radius/totalMass);}
      }
    }
  }

  // Коллизия с линиями (стены/шипы)
  arr.forEach(ball=>{
    state.walls.concat(state.spikes).forEach(line=>{
      // Простейшая AABB коллизия
      const closestX=Math.max(line.x, Math.min(ball.x, line.x+line.w));
      const closestY=Math.max(line.y, Math.min(ball.y, line.y+line.h));
      const dx=ball.x-closestX, dy=ball.y-closestY;
      const dist=Math.hypot(dx,dy);
      if(dist<ball.radius){
        const overlap=ball.radius-dist;
        const nx=dx/dist||0, ny=dy/dist||0;
        ball.x+=nx*overlap; ball.y+=ny*overlap;
        const vn=ball.vx*nx + ball.vy*ny;
        ball.vx-=2*vn*nx; ball.vy-=2*vn*ny;
      }
    });
  });

  // Обновление DOM
  arr.forEach(obj=>{
    if(obj.popping) return;
    obj.el.style.width=obj.radius*2+'px';
    obj.el.style.height=obj.radius*2+'px';
    obj.el.style.left=(obj.x-obj.radius)+'px';
    obj.el.style.top=(obj.y-obj.radius)+'px';
    obj.el.querySelector('.label').textContent=`x${obj.multiplier.toFixed(2)}`;
  });

  roundCounter-=sec;
  if(roundCounter<=0){
    arr.forEach(o=>cashSelected());
    arr.forEach(o=>{try{o.el.remove()}catch{}});
    state.balloons.clear(); roundCounter=CFG.roundTime; generateWalls();
  }

  refresh(); requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

// Создание шара при клике на поле
arena.addEventListener('pointerdown', e=>{
  if(state.balance<CFG.price) return;
  const rect=arena.getBoundingClientRect();
  const x=e.clientX-rect.left, y=e.clientY-rect.top;
  state.balance-=CFG.price; save(); createBalloon(x,y,CFG.price); refresh();
});
</script>
</body>
</html>
