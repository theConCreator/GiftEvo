<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Balloon Blast — прототип арены</title>
  <style>
    :root{
      --bg:#0f1724;
      --arena:#0b1220;
      --panel:#071022;
      --accent:#60a5fa;
      --danger:#ff6b6b;
      --glass: rgba(255,255,255,0.03);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071428);color:#e6eef8}
    .app{display:flex;gap:18px;padding:18px;box-sizing:border-box;height:100%;}

    /* Left - arena */
    .left{flex:1;display:flex;flex-direction:column;gap:12px}
    .arena-panel{flex:1;background:linear-gradient(180deg,var(--arena),#071228);border-radius:12px;padding:12px;position:relative;overflow:hidden;box-shadow:0 6px 24px rgba(2,6,23,.6)}
    .arena-topbar{display:flex;justify-content:space-between;align-items:center;padding:6px 10px;color:#cfe6ff88}
    .arena{position:relative;flex:1;border-radius:10px;background:linear-gradient(180deg,#07112a, #0b1530);height:calc(100% - 48px);overflow:hidden;border:1px solid rgba(255,255,255,0.03)}

    /* balloons are absolutely positioned divs */
    .balloon{position:absolute;border-radius:50%;display:flex;align-items:center;justify-content:center;cursor:pointer;user-select:none;touch-action:none;transition:transform 120ms linear}
    .balloon .label{font-weight:700;font-size:12px;color:rgba(255,255,255,0.95);text-shadow:0 1px 0 rgba(0,0,0,0.5)}
    .shadow{position:absolute;left:50%;transform:translateX(-50%);bottom:8px;width:60px;height:8px;border-radius:999px;opacity:.18;filter:blur(6px)}

    /* Right - controls */
    .right{width:360px;display:flex;flex-direction:column;gap:12px}
    .card{background:var(--panel);border-radius:10px;padding:12px;border:1px solid rgba(255,255,255,0.03)}
    .balance{font-size:20px;font-weight:700;color:var(--accent)}
    .controls{display:flex;gap:8px;align-items:center}
    .btn{background:linear-gradient(180deg,#16325a,#0f2746);padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);cursor:pointer;color:#e9f6ff;font-weight:600}
    .btn.warn{background:linear-gradient(180deg,#7f1d1d,#491212);}
    .small{padding:6px 8px;font-size:13px}

    .meta{font-size:13px;color:#bcd8ff88}
    .log{height:220px;overflow:auto;padding:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:8px}

    footer{font-size:12px;color:#9fb7d9cc;margin-top:6px}

    /* pop animation */
    .pop{animation:popAnim .45s ease forwards}
    @keyframes popAnim{
      0%{transform:scale(1);opacity:1}
      60%{transform:scale(1.8);opacity:.9}
      100%{transform:scale(2.6);opacity:0}
    }

    /* responsive */
    @media (max-width:900px){.right{display:none}.app{padding:12px}}
  </style>
</head>
<body>
  <div class="app">
    <div class="left">
      <div class="card arena-panel">
        <div class="arena-topbar">
          <div>Арена — нажмите и удерживайте по пространству, чтобы разместить шар; удерживайте шар, чтобы надувать.</div>
          <div class="meta">Шары: <span id="balloonCount">0</span></div>
        </div>
        <div id="arena" class="arena" tabindex="0" aria-label="Игровая арена"></div>
      </div>
      <div class="card" style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div style="font-size:14px;color:#bfdfff">Текущее выделение</div>
          <div id="currentInfo" style="font-weight:700">—</div>
        </div>
        <div style="display:flex;flex-direction:column;gap:8px;align-items:flex-end">
          <button id="cashBtn" class="btn" disabled>Забрать</button>
          <div class="meta">Автосохранение локально</div>
        </div>
      </div>
    </div>

    <div class="right">
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div class="meta">Баланс (симуляция)</div>
            <div class="balance" id="balance">1000</div>
          </div>
          <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end">
            <button id="buyBtn" class="btn">Купить шар</button>
            <div class="meta">Цена по умолчанию: 10</div>
          </div>
        </div>

        <hr style="margin:10px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)" />
        <div style="display:flex;gap:8px;align-items:center">
          <button id="seedBtn" class="btn small">Сброс / Новая сессия</button>
          <button id="demoBtn" class="btn small">Демо: спавн шар автоматически</button>
          <button id="rulesBtn" class="btn small">Показать правила</button>
        </div>
      </div>

      <div class="card">
        <div style="font-weight:700;margin-bottom:6px">Лог событий</div>
        <div id="log" class="log"></div>
        <footer>Подсказка: интеграция с сервером — см. комментарии в коде</footer>
      </div>
    </div>
  </div>

  <script>
    /*
      Balloon Blast – прототип фронтенда
      - Нажмите и удерживайте островок в арене, чтобы разместить шар (pointerdown на пустом месте создаёт шар)
      - Чтобы надуть шар: удерживайте этот шар (pointerdown на самом шаре). При удержании шар растёт.
      - Можно отпустить и снова зажать тот же шар, чтобы продолжить поддувать.
      - Нажмите "Забрать" чтобы получить награду по текущему множителю. Если шар лопнет — вы теряете вложение.
      - Этот код — прототип. Точки интеграции с сервером отмечены TODO.
    */

    // ----- Конфигурация -----
    const CONFIG = {
      basePrice: 10,            // цена покупки шарика (симуляция)
      inflationPerSec: 18,      // пикселей радиуса в секунду при удержании
      minRadius: 18,
      maxSafeRadius: 160,       // после этого шанс резко растёт
      popBasePerSec: 0.02,      // базовый шанс взрыва в секунду (2%)
      popRadiusFactor: 0.004,   // добавочный шанс на каждый пикс radius
      multiplierBase: 1.0,      // множитель при минимальном размере
      multiplierCurve: 0.014,   // как размер переводится в икс
      autoframeMs: 60          // частота обновления (ms)
    }

    // ----- Состояние -----
    let state = {
      balance: Number(localStorage.getItem('bb_balance')) || 1000,
      balloons: new Map(), // id -> balloonObj
      selectedBalloonId: null,
      nextId: 1
    }

    // Элементы DOM
    const arena = document.getElementById('arena')
    const balanceEl = document.getElementById('balance')
    const buyBtn = document.getElementById('buyBtn')
    const cashBtn = document.getElementById('cashBtn')
    const currentInfo = document.getElementById('currentInfo')
    const balloonCount = document.getElementById('balloonCount')
    const logEl = document.getElementById('log')
    const demoBtn = document.getElementById('demoBtn')
    const seedBtn = document.getElementById('seedBtn')
    const rulesBtn = document.getElementById('rulesBtn')

    function saveState(){
      localStorage.setItem('bb_balance', state.balance)
    }

    function log(msg){
      const time = new Date().toLocaleTimeString()
      logEl.insertAdjacentHTML('afterbegin', `<div style="margin-bottom:6px"><b>[${time}]</b> ${escapeHtml(msg)}</div>`)
    }

    function escapeHtml(s){ return (s+'').replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])) }

    function refreshUI(){
      balanceEl.textContent = state.balance.toFixed(2)
      balloonCount.textContent = state.balloons.size
      const sel = state.selectedBalloonId ? state.balloons.get(state.selectedBalloonId) : null
      if(sel){
        currentInfo.innerHTML = `ID ${sel.id} · R=${Math.round(sel.radius)} · x${sel.multiplier.toFixed(2)} · ${sel.state}`
        cashBtn.disabled = false
      } else {
        currentInfo.textContent = '—'
        cashBtn.disabled = true
      }
    }

    // ----- Балун объект -----
    function createBalloon(x, y, price){
      const id = state.nextId++
      const el = document.createElement('div')
      el.className = 'balloon'
      el.style.left = (x)+'px'
      el.style.top = (y)+'px'
      el.style.width = (CONFIG.minRadius*2)+'px'
      el.style.height = (CONFIG.minRadius*2)+'px'
      el.style.transform = 'translate(-50%,-50%) scale(1)'
      el.dataset.id = id
      // color
      const hue = Math.floor(Math.random()*360)
      el.style.background = `radial-gradient(circle at 30% 30%, hsla(${hue},95%,70%,0.95), hsla(${hue},80%,45%,0.95))`
      el.style.boxShadow = `0 10px 30px rgba(2,8,23,0.6), inset 0 -6px 18px rgba(0,0,0,0.24)`
      // label
      const lbl = document.createElement('div')
      lbl.className = 'label'
      lbl.textContent = 'x1.00'
      el.appendChild(lbl)

      // shadow
      const shadow = document.createElement('div')
      shadow.className = 'shadow'
      shadow.style.background = 'radial-gradient(ellipse at center, rgba(0,0,0,0.5), rgba(0,0,0,0))'
      shadow.style.width = '60px'

      arena.appendChild(el)
      arena.appendChild(shadow)

      const obj = {
        id, el, shadow,
        x, y,
        radius: CONFIG.minRadius,
        price: price || CONFIG.basePrice,
        createdAt: Date.now(),
        inflatedMs: 0,
        lastInflateAt: null,
        popping: false,
        state: 'idle', // idle | inflating | safe | popped | cashed
        multiplier: CONFIG.multiplierBase
      }

      // pointer events to inflate the particular balloon
      let pointerActive = false
      function onPointerDown(ev){
        if(obj.popping || obj.state==='popped' || obj.state==='cashed') return
        pointerActive = true
        obj.state = 'inflating'
        obj.lastInflateAt = performance.now()
        // select
        state.selectedBalloonId = obj.id
        refreshUI()
        ev.preventDefault()
      }
      function onPointerUp(ev){
        if(pointerActive){
          pointerActive = false
          obj.state = 'idle'
          obj.lastInflateAt = null
          refreshUI()
        }
      }

      el.addEventListener('pointerdown', onPointerDown)
      window.addEventListener('pointerup', onPointerUp)
      // to allow reselect via tap
      el.addEventListener('click',()=>{ state.selectedBalloonId = obj.id; refreshUI() })

      state.balloons.set(id, obj)
      log(`Шар ${id} размещён (цена ${obj.price}).`) 

      // TODO: здесь можно вызвать серверный хук: onPlaceBalloon({id,x,y,price})

      return obj
    }

    // ----- механика инфляции и шанс взрыва -----
    let lastFrame = performance.now()
    function tick(now){
      const dt = Math.max(0, now - lastFrame)
      lastFrame = now
      for(const [id,obj] of state.balloons){
        // if inflating
        if(obj.state==='inflating'){
          obj.inflatedMs += dt
          const add = (CONFIG.inflationPerSec * (dt/1000))
          obj.radius = Math.min(360, obj.radius + add) // hard cap
        }
        // update multiplier (simple curve)
        obj.multiplier = CONFIG.multiplierBase + Math.pow(1 + CONFIG.multiplierCurve*obj.radius, 1.02) - 1

        // compute pop chance per tick
        const sec = dt/1000
        const popChance = 1 - Math.exp(- (CONFIG.popBasePerSec + (obj.radius * CONFIG.popRadiusFactor)) * sec )
        if(!obj.popping && Math.random() < popChance){
          // POP!
          doPop(obj)
        }

        // update DOM size & label
        obj.el.style.width = (obj.radius*2)+'px'
        obj.el.style.height = (obj.radius*2)+'px'
        obj.el.style.left = obj.x + 'px'
        obj.el.style.top = obj.y + 'px'
        obj.shadow.style.left = (obj.x - 30) + 'px'
        obj.shadow.style.bottom = (10 - obj.radius/20) + 'px'
        obj.shadow.style.opacity = Math.max(0.06, Math.min(0.28, obj.radius/180))
        obj.shadow.style.width = Math.max(36, Math.min(150, obj.radius*1.2))
        obj.el.querySelector('.label').textContent = `x${obj.multiplier.toFixed(2)}`
      }

      refreshUI()
      requestAnimationFrame(tick)
    }
    requestAnimationFrame(tick)

    function doPop(obj){
      obj.popping = true
      obj.state = 'popped'
      obj.el.classList.add('pop')
      log(`Шар ${obj.id} лопнул на x${obj.multiplier.toFixed(2)}! Проигрыш вложения ${obj.price}.`)

      // TODO: вызвать серверный хук onPop({id, multiplier, lostPrice})

      // remove after animation
      setTimeout(()=>{
        try{ obj.el.remove(); obj.shadow.remove() }catch(e){}
        state.balloons.delete(obj.id)
        if(state.selectedBalloonId===obj.id) state.selectedBalloonId = null
      },450)
    }

    function cashOutSelected(){
      const id = state.selectedBalloonId
      if(!id) return
      const obj = state.balloons.get(id)
      if(!obj) return
      if(obj.popping) return

      // payout calculation
      const payout = obj.price * obj.multiplier
      state.balance += payout
      saveState()
      log(`Шар ${obj.id} забран — выплата ${payout.toFixed(2)} (x${obj.multiplier.toFixed(2)})`).
      // visual
      obj.state = 'cashed'
      obj.el.classList.add('pop')
      // TODO: здесь должен быть серверный вызов: onCashOut({id, multiplier, payout})

      setTimeout(()=>{
        try{ obj.el.remove(); obj.shadow.remove() }catch(e){}
        state.balloons.delete(obj.id)
        if(state.selectedBalloonId===obj.id) state.selectedBalloonId = null
      }, 420)
    }

    // ----- Arena placement: pointerdown on arena creates balloon and begins inflating immediately -----
    let placing = false
    let placingObj = null
    arena.addEventListener('pointerdown', (ev)=>{
      // do not create if clicking existing balloon
      const target = ev.target
      if(target.classList && target.classList.contains('balloon')) return

      // if user has enough balance
      if(state.balance < CONFIG.basePrice){ log('Недостаточно средств для покупки шарика.'); return }

      // subtract price (simulate purchase)
      state.balance -= CONFIG.basePrice
      saveState()

      const rect = arena.getBoundingClientRect()
      const x = ev.clientX - rect.left
      const y = ev.clientY - rect.top
      placingObj = createBalloon(x, y, CONFIG.basePrice)
      // start inflating immediately
      placingObj.state = 'inflating'
      placingObj.lastInflateAt = performance.now()
      state.selectedBalloonId = placingObj.id
      // prevent default to avoid selection
      ev.preventDefault()
    })

    // release anywhere will stop inflating the currently active balloon (if any)
    window.addEventListener('pointerup', ()=>{
      if(placingObj){
        if(placingObj.state==='inflating') placingObj.state='idle'
        placingObj.lastInflateAt = null
        placingObj = null
        refreshUI()
      }
    })

    // Buy button (creates balloon near center)
    buyBtn.addEventListener('click', ()=>{
      if(state.balance < CONFIG.basePrice){ log('Недостаточно средств.'); return }
      state.balance -= CONFIG.basePrice
      saveState()
      const r = arena.getBoundingClientRect()
      const x = Math.random()*(r.width-100)+50
      const y = Math.random()*(r.height-100)+50
      const b = createBalloon(x,y, CONFIG.basePrice)
      state.selectedBalloonId = b.id
      refreshUI()
    })

    cashBtn.addEventListener('click', ()=>{
      cashOutSelected()
      refreshUI()
    })

    demoBtn.addEventListener('click', ()=>{
      // spawn demo balloons in random positions that auto-inflate then cash out (for demo)
      for(let i=0;i<3;i++){
        const r = arena.getBoundingClientRect()
        const x = Math.random()*(r.width-120)+60
        const y = Math.random()*(r.height-120)+60
        const b = createBalloon(x,y, CONFIG.basePrice)
        // auto-inflate for random time
        const t = 800 + Math.random()*2200
        b.state='inflating'
        setTimeout(()=>{ b.state='idle' }, t)
      }
    })

    seedBtn.addEventListener('click', ()=>{
      // clear arena
      for(const [id,obj] of state.balloons){ try{ obj.el.remove(); obj.shadow.remove() }catch(e){} }
      state.balloons.clear()
      state.selectedBalloonId = null
      state.balance = 1000
      saveState()
      log('Сессия сброшена.')
      refreshUI()
    })

    rulesBtn.addEventListener('click', ()=>{
      alert(`Правила:\n- Нажмите в свободном месте арены чтобы разместить шар (списание цены).\n- Удерживайте палец/мышку на шаре, чтобы надувать его — множитель растёт.\n- Шанс лопнуть растёт с размером.\n- Нажмите "Забрать", чтобы получить выплату по текущему множителю (или интегрируйте это с реальным платёжным бэком).`)
    })

    // init
    refreshUI()

    // ==== ВАЖНЫЕ ЗАМЕТКИ ДЛЯ ИНТЕГРАЦИИ С СЕРВЕРОМ ====
    // 1) ВСЕ платежные операции (покупка шарика, выплата при забирании, учёт подарков) должны происходить на сервере.
    //    Клиент только инициирует запросы: onPlaceBalloon, onInflateTick, onCashOut, onPop.
    // 2) Для честности и аудита модель RNG и обработка взрывов лучше держать на сервере.
    // 3) Поддержка мультиплеера/общей арены потребует вебсокетов: сервер рассылает апдейты о состоянии шаров всем клиентам.
    // 4) Для защиты от читов — никогда не доверяйте голосам клиента по размеру/времени, проверяйте все транзакции на сервере.

  </script>
</body>
</html>