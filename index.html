<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Прыгающая Кирка - Minecraft Arcade</title>
    <style>
        /* CSS Стили для фиксированного макета */
        body {
            background-color: #282c34;
            color: #fff;
            font-family: 'Courier New', monospace;
            /* Фиксируем макет по центру, убираем прокрутку */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden; /* Убираем прокрутку */
        }

        h1, p {
            margin: 5px 0;
        }

        #game-container {
            display: flex;
            flex-direction: row;
            border: 5px solid #000;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            background-color: #444; 
            margin-top: 10px;
        }

        #info-panel {
            width: 150px; 
            background-color: #333;
            padding: 10px;
            text-align: left;
            border-right: 2px solid #000;
            font-size: 0.9em;
        }

        #info-panel h3 {
            margin-top: 0;
            text-align: center;
        }

        .resource-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .resource-color {
            width: 14px;
            height: 14px;
            margin-right: 8px;
            border: 1px solid #111;
        }

        #game-canvas {
            display: block; 
            background-color: #6d6d6d;
        }
        
        button {
            margin-top: 20px; 
            padding: 10px 20px; 
            font-size: 1.2em;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <h1>⛏️ Прыгающая Кирка</h1>
    <p>Цель: набрать как можно больше алмазов, копая бесконечно!</p>

    <div id="game-container">
        <div id="info-panel">
            <h3>Ресурсы:</h3>
            <div class="resource-item"><div class="resource-color" style="background-color: #555555;"></div>Уголь: <span id="coal-count">0</span></div>
            <div class="resource-item"><div class="resource-color" style="background-color: #c7c7c7;"></div>Железо: <span id="iron-count">0</span></div>
            <div class="resource-item"><div class="resource-color" style="background-color: #ffcc00;"></div>Золото: <span id="gold-count">0</span></div>
            <div class="resource-item"><div class="resource-color" style="background-color: #66ffff;"></div>Алмазы: <span id="diamond-count">0</span></div>
            <p>Глубина: <span id="depth-count">0</span> м</p>
        </div>
        
        <canvas id="game-canvas"></canvas>
    </div>
    
    <button onclick="startGame()">Запустить Кирку!</button>

    <script>
        // JavaScript Логика Игры
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const button = document.querySelector('button');
        const depthDisplay = document.getElementById('depth-count');

        // --- Константы ---
        const BLOCK_SIZE = 40; // Немного увеличенный размер блока для более крупной кирки
        const GAME_WIDTH = 9; // 1 (Стена) + 7 (Блоков) + 1 (Стена)
        const GAME_HEIGHT = 20;
        
        // Константы для более медленного и реалистичного движения
        const INITIAL_DROP_VELOCITY = 1; // Стартовый импульс
        const INITIAL_JUMP_VELOCITY = -8; // Скорость прыжка вверх
        const GRAVITY = 0.3; // Ускорение свободного падения (более медленное)
        const HORIZONTAL_MOMENTUM = 2; // Горизонтальный импульс

        // Константы для бесконечной прокрутки
        const SCROLL_ROWS = 10; // Сколько рядов генерировать/удалять за раз
        const SCROLL_THRESHOLD = 8 * BLOCK_SIZE; // Прокрутка, когда кирка опускается ниже 8-го ряда с вершины экрана

        canvas.width = GAME_WIDTH * BLOCK_SIZE;
        canvas.height = GAME_HEIGHT * BLOCK_SIZE;

        // --- Типы Блоков ---
        const BLOCK_TYPES = {
            AIR: 0,
            STONE: 1,
            COAL: 2,
            IRON: 3,
            GOLD: 4,
            DIAMOND: 5,
            WALL: 9 // Неразрушимая стена
        };

        const BLOCK_COLORS = {
            [BLOCK_TYPES.STONE]: '#a0a0a0',
            [BLOCK_TYPES.COAL]: '#555555',
            [BLOCK_TYPES.IRON]: '#c7c7c7',
            [BLOCK_TYPES.GOLD]: '#ffcc00',
            [BLOCK_TYPES.DIAMOND]: '#66ffff',
            [BLOCK_TYPES.WALL]: '#363636' // Цвет стены
        };

        // --- Состояние Игры ---
        let gameGrid = [];
        let currentDepth = 0; // Текущая глубина в блоках (отсчет снизу)
        let pickaxe = {
            x: GAME_WIDTH / 2 * BLOCK_SIZE, 
            y: 0, 
            vy: 0, 
            vx: 0,
            radius: BLOCK_SIZE / 2 
        };
        let resources = {
            [BLOCK_TYPES.COAL]: 0,
            [BLOCK_TYPES.IRON]: 0,
            [BLOCK_TYPES.GOLD]: 0,
            [BLOCK_TYPES.DIAMOND]: 0
        };
        let gameInterval = null;

        // --- Функции Инициализации и Генерации ---
        
        function generateNewChunk(chunkHeight) {
            const newChunk = [];
            for (let y = 0; y < chunkHeight; y++) {
                const row = [];
                for (let x = 0; x < GAME_WIDTH; x++) {
                    // Левая и Правая Стены
                    if (x === 0 || x === GAME_WIDTH - 1) {
                        row.push(BLOCK_TYPES.WALL);
                        continue;
                    }

                    // Логика Генерации Руды (зависит от абсолютной глубины)
                    const absoluteY = currentDepth + y; 
                    let type = BLOCK_TYPES.STONE;
                    const rand = Math.random();

                    // Шансы руды увеличиваются с глубиной
                    if (absoluteY > 50 && rand < 0.02) type = BLOCK_TYPES.DIAMOND;
                    else if (absoluteY > 30 && rand < 0.07) type = BLOCK_TYPES.GOLD;
                    else if (absoluteY > 10 && rand < 0.15) type = BLOCK_TYPES.IRON;
                    else if (rand < 0.25) type = BLOCK_TYPES.COAL;
                    
                    row.push(type);
                }
                newChunk.push(row);
            }
            currentDepth += chunkHeight;
            return newChunk;
        }

        function generateInitialGrid() {
            gameGrid = [];
            currentDepth = 0;
            
            // 1. Добавляем "Воздух" в начале, чтобы кирка могла упасть
            for(let y = 0; y < 3; y++) {
                gameGrid.push(new Array(GAME_WIDTH).fill(BLOCK_TYPES.AIR));
            }
            currentDepth = 3; 

            // 2. Генерируем начальный большой кусок мира
            const INITIAL_GENERATION_HEIGHT = GAME_HEIGHT * 2;
            const chunk = generateNewChunk(INITIAL_GENERATION_HEIGHT);
            gameGrid = gameGrid.concat(chunk);
        }

        function resetPickaxe() {
            pickaxe.x = GAME_WIDTH / 2 * BLOCK_SIZE;
            pickaxe.y = pickaxe.radius; 
            pickaxe.vy = INITIAL_DROP_VELOCITY; // Даем стартовый импульс
            pickaxe.vx = 0;
        }

        function startGame() {
            if (gameInterval) clearInterval(gameInterval);
            
            generateInitialGrid(); 
            resetPickaxe();
            Object.keys(resources).forEach(key => resources[key] = 0);
            updateResourcesDisplay();
            
            button.disabled = true;
            button.innerText = "Кирка в работе...";
            
            gameInterval = setInterval(gameLoop, 1000 / 60); 
        }

        // --- Отрисовка ---

        function drawBlock(x, y, type) {
            if (type === BLOCK_TYPES.AIR) return;

            ctx.fillStyle = BLOCK_COLORS[type] || '#555';
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            ctx.strokeStyle = '#00000033'; 
            ctx.lineWidth = 1;
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            if (type !== BLOCK_TYPES.STONE && type !== BLOCK_TYPES.WALL) {
                // Имитация пиксельной текстуры (руды)
                ctx.fillStyle = 'black';
                for (let i = 0; i < 4; i++) {
                    const px = x * BLOCK_SIZE + Math.floor(Math.random() * BLOCK_SIZE);
                    const py = y * BLOCK_SIZE + Math.floor(Math.random() * BLOCK_SIZE);
                    ctx.fillRect(px, py, 2, 2);
                }
            }
        }

        function drawPickaxe() {
            // Рисуем кирку (Железный/Каменный стиль, масштабируется с BLOCK_SIZE)
            const S = BLOCK_SIZE / 16; 
            const centerX = pickaxe.x;
            const centerY = pickaxe.y;
            // Координаты смещения, чтобы центрировать спрайт
            const x = centerX - 10 * S; 
            const y = centerY - 10 * S; 

            const BLADE_COLOR = '#a0a0a0'; 
            const STICK_COLOR = '#964b00';

            const pixelArt = [
                // Рукоятка (Коричневый)
                {c: STICK_COLOR, x: 12, y: 12, w: 2, h: 4},
                {c: STICK_COLOR, x: 10, y: 0, w: 2, h: 12},

                // Лезвие (Камень)
                {c: BLADE_COLOR, x: 0, y: 8, w: 10, h: 2}, 
                {c: BLADE_COLOR, x: 8, y: 6, w: 2, h: 2}, 
                {c: BLADE_COLOR, x: 10, y: 10, w: 2, h: 2},
            ];
            
            ctx.strokeStyle = '#00000088'; 
            ctx.lineWidth = 1;

            pixelArt.forEach(p => {
                ctx.fillStyle = p.c;
                ctx.fillRect(x + p.x * S, y + p.y * S, p.w * S, p.h * S);
            });
            
            ctx.strokeRect(x + 10 * S, y, 2 * S, 12 * S);
            ctx.strokeRect(x, y + 8 * S, 10 * S, 2 * S);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Отрисовка сетки блоков
            // Отрисовываем только те блоки, которые помещаются на холсте (GAME_HEIGHT)
            for (let y = 0; y < GAME_HEIGHT; y++) {
                for (let x = 0; x < GAME_WIDTH; x++) {
                    // Используем gameGrid[y] - это уже видимый кусок мира
                    if(gameGrid[y]) {
                         drawBlock(x, y, gameGrid[y][x]);
                    }
                }
            }

            // Отрисовка кирки
            drawPickaxe();
        }

        // --- Игровая Логика ---

        function updateResourcesDisplay() {
            document.getElementById('coal-count').innerText = resources[BLOCK_TYPES.COAL];
            document.getElementById('iron-count').innerText = resources[BLOCK_TYPES.IRON];
            document.getElementById('gold-count').innerText = resources[BLOCK_TYPES.GOLD];
            document.getElementById('diamond-count').innerText = resources[BLOCK_TYPES.DIAMOND];
            depthDisplay.innerText = currentDepth * 1; // Отображаем глубину
        }

        function update() {
            // 1. Применяем гравитацию
            pickaxe.vy += GRAVITY;

            // 2. Обновление позиции
            pickaxe.y += pickaxe.vy; 
            pickaxe.x += pickaxe.vx;
            
            // 3. Проверка границ по горизонтали (стены)
            if (pickaxe.x <= pickaxe.radius + BLOCK_SIZE || pickaxe.x >= canvas.width - pickaxe.radius - BLOCK_SIZE) {
                pickaxe.vx *= -1;
                // Скорректируем позицию, чтобы не застревала в стене
                pickaxe.x = Math.max(pickaxe.radius + BLOCK_SIZE, Math.min(canvas.width - pickaxe.radius - BLOCK_SIZE, pickaxe.x));
            }

            // 4. Проверка границ по вертикали (Потолок)
            if (pickaxe.y <= pickaxe.radius) {
                pickaxe.vy = Math.abs(pickaxe.vy); 
                pickaxe.y = pickaxe.radius;
            }
            
            // 5. Проверка столкновений с блоками
            const gridX = Math.floor(pickaxe.x / BLOCK_SIZE);
            const gridY = Math.floor(pickaxe.y / BLOCK_SIZE);

            if (gridY >= 0 && gridY < GAME_HEIGHT && gridX >= 0 && gridX < GAME_WIDTH) {
                const blockType = gameGrid[gridY][gridX];

                if (blockType !== BLOCK_TYPES.AIR && blockType !== BLOCK_TYPES.WALL) {
                    // Столкновение с добываемым блоком!
                    
                    // a) Добыча ресурса
                    if (resources[blockType] !== undefined) {
                        resources[blockType]++;
                        updateResourcesDisplay();
                    }

                    // b) Удаление блока
                    gameGrid[gridY][gridX] = BLOCK_TYPES.AIR;
                    
                    // c) Реалистичный Прыжок (толчок вверх)
                    pickaxe.vy = INITIAL_JUMP_VELOCITY; 
                    
                    // d) Случайный горизонтальный сдвиг
                    const jumpDirection = Math.random() < 0.5 ? -1 : 1;
                    pickaxe.vx += jumpDirection * HORIZONTAL_MOMENTUM * Math.random(); 
                    pickaxe.vx = Math.max(-10, Math.min(10, pickaxe.vx)); 
                }
            }
            
            // 6. Реализация бесконечной прокрутки вниз
            if (pickaxe.y > SCROLL_THRESHOLD) {
                const scrollAmount = SCROLL_ROWS * BLOCK_SIZE;
                
                // Перемещаем кирку обратно вверх на ту же величину
                pickaxe.y -= scrollAmount;
                
                // Удаляем верхние ряды
                gameGrid.splice(0, SCROLL_ROWS); 
                
                // Генерируем новые ряды внизу
                const newRows = generateNewChunk(SCROLL_ROWS);
                gameGrid = gameGrid.concat(newRows);

                // Глубина обновилась внутри generateNewChunk
                updateResourcesDisplay();
            }

            // 7. Завершение игры (если кирка вылетела за пределы экрана слишком далеко вверх, что маловероятно при текущей логике, но безопасно)
            if (pickaxe.y > canvas.height + pickaxe.radius * 2) {
                 // Если кирка падает слишком далеко, это конец игры (если нет блоков внизу)
                clearInterval(gameInterval);
                gameInterval = null;
                button.disabled = false;
                button.innerText = "Игра окончена! Запустить снова.";
                alert(`Кирка упала! Достигнутая глубина: ${currentDepth} м. Ваши алмазы: ${resources[BLOCK_TYPES.DIAMOND]}`);
                return;
            }
        }

        function gameLoop() {
            update();
            draw();
        }

        // Инициализация при загрузке страницы
        generateInitialGrid();
        updateResourcesDisplay(); // Показать 0 ресурсов
        draw(); 
    </script>

</body>
</html>