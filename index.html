<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Balloon Arena — Stable Build</title>
<style>
:root{--bg1:#071025;--bg2:#081733;--card:#071428;--accent:#5ec0ff;--danger:#ff6b6b;font-family:Inter,system-ui, -apple-system,'Segoe UI',Roboto,Arial}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent;user-select:none}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:#eaf6ff;overflow:hidden}
.container{width:420px;margin:12px auto;height:840px;display:flex;flex-direction:column;gap:12px}
.header{display:flex;justify-content:space-between;align-items:center}
.panel{background:rgba(255,255,255,0.03);border-radius:12px;padding:10px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 10px 30px rgba(0,0,0,0.5)}
#arena{width:100%;height:600px;border-radius:10px;background:linear-gradient(180deg,#071022,#051223);position:relative;overflow:hidden}
.balloon{position:absolute;border-radius:50%;display:flex;align-items:center;justify-content:center;cursor:grab;touch-action:none;box-shadow:0 8px 30px rgba(0,0,0,0.5)}
.balloon .label{pointer-events:none;color:white;font-weight:800;font-size:12px;text-shadow:0 1px 0 rgba(0,0,0,0.5)}
.line-vert{position:absolute;background:linear-gradient(180deg,#3ea6ff,#2b8ee6)}
.line-horz{position:absolute;background:linear-gradient(90deg,#ff6b6b,#ff3a3a)}
.burst{position:absolute;border-radius:50%;pointer-events:none;transform:translate(-50%,-50%);}
@keyframes burstAnim{0%{transform:translate(-50%,-50%) scale(0.2);opacity:1}50%{transform:translate(-50%,-50%) scale(1.6);opacity:0.9}100%{transform:translate(-50%,-50%) scale(3);opacity:0}}
.controls{display:flex;flex-direction:column;gap:8px}
.btn{background:linear-gradient(180deg,#16325a,#0f2746);color:#e9f6ff;border-radius:10px;padding:10px;font-weight:800;border:1px solid rgba(255,255,255,0.04);cursor:pointer}
.btn:disabled{opacity:.5;cursor:not-allowed}
.hud{display:flex;gap:8px;align-items:center}
.badge{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:8px}
.small{font-size:12px;color:#9fb7d9}
.results{height:120px;overflow:auto;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px}
.footer{font-size:12px;color:#9fb7d9cc;margin-top:6px}
</style>
</head>
<body>
<div class="container">
  <div class="header panel">
    <div style="display:flex;flex-direction:column">
      <div style="font-weight:900">Balloon Arena</div>
      <div class="small">Купи слот — размести шар — наблюдай за раундом</div>
    </div>
    <div class="hud">
      <div class="badge">Фаза: <span id="phase">BUY</span></div>
      <div class="badge">Раунд: <span id="roundTimer">—</span>s</div>
      <div class="badge">Слоты: <span id="slotsLeft">0</span></div>
    </div>
  </div>

  <div id="arena" class="panel"></div>

  <div class="panel controls">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>Баланс: <b id="balance">1000</b></div>
      <div class="small">Локальная демо-версия</div>
    </div>
    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="buyBtn" class="btn">Купить слот (10)</button>
      <button id="toPlaceBtn" class="btn" disabled>Перейти к размещению</button>
      <button id="startBtn" class="btn" disabled>Старт раунда</button>
    </div>
    <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px">
      <div class="small">Событие раунда:</div>
      <div id="eventName" class="small">—</div>
    </div>
    <div style="display:flex;justify-content:space-between;align-items:center;margin-top:6px">
      <div class="small">Ветер:</div>
      <div id="windVal" class="small">0.0, 0.0</div>
    </div>
    <div id="results" class="results"></div>
    <div class="footer">Правила: покупайте слоты, затем размещайте шары удерживая на поле. Шипы лопают шар, стены отталкивают.</div>
  </div>
</div>

<script>
// ===== CONFIG =====
const CFG = {
  price:10,
  buyPhaseSec:12,
  roundSec:30,
  minR:18,
  maxR:200,
  inflatePerSec:28,
  popBase:0.002,
  popR:0.0009,
  friction:0.995,
  bounce:0.86,
  windStrength:3.5,
  grid:5,
  lineThickness:6,
  eventChance:0.7
};

// ===== STATE =====
const state = {
  balance: Number(localStorage.getItem('bb_balance')) || 1000,
  phase: 'buy', // buy, place, run
  purchasedSlots: 0,
  placedCount: 0,
  balloons: new Map(),
  nextId: 1,
  lines: [], // {type,x,y,w,h,el}
  wind: {x:0,y:0},
  event: null, // null|'wind'|'blackhole'|'bounce'
  buyTimer: CFG.buyPhaseSec,
  roundTimer: CFG.roundSec
};

// ===== DOM =====
const arena = document.getElementById('arena');
const balanceEl = document.getElementById('balance');
const phaseEl = document.getElementById('phase');
const slotsLeftEl = document.getElementById('slotsLeft');
const roundTimerEl = document.getElementById('roundTimer');
const buyBtn = document.getElementById('buyBtn');
const toPlaceBtn = document.getElementById('toPlaceBtn');
const startBtn = document.getElementById('startBtn');
const eventNameEl = document.getElementById('eventName');
const windValEl = document.getElementById('windVal');
const resultsEl = document.getElementById('results');

function save(){ localStorage.setItem('bb_balance', state.balance); }
function log(msg){ const t=new Date().toLocaleTimeString(); resultsEl.insertAdjacentHTML('afterbegin', `<div><b>[${t}]</b> ${msg}</div>`); }
function uiUpdate(){ balanceEl.textContent = state.balance.toFixed(2); phaseEl.textContent = state.phase.toUpperCase(); slotsLeftEl.textContent = state.purchasedSlots - state.placedCount; roundTimerEl.textContent = Math.ceil(state.phase==='run' ? state.roundTimer : state.phase==='buy' ? state.buyTimer : 0); eventNameEl.textContent = state.event || '—'; windValEl.textContent = `${state.wind.x.toFixed(1)}, ${state.wind.y.toFixed(1)}`; buyBtn.disabled = state.phase !== 'buy'; toPlaceBtn.disabled = state.phase !== 'buy' || state.purchasedSlots===0; startBtn.disabled = state.phase !== 'place'; }

// ===== UTIL =====
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// ===== LINES (walls/spikes) generation =====
function clearLines(){ state.lines.forEach(L=>{ try{ L.el.remove(); }catch{} }); state.lines = []; }
function generateLines(){ clearLines(); const W=arena.clientWidth, H=arena.clientHeight; const stepX=W/CFG.grid, stepY=H/CFG.grid; for(let gx=0;gx<CFG.grid;gx++){ for(let gy=0;gy<CFG.grid;gy++){ const r=Math.random(); if(r<0.09){ // vertical wall
        const x = gx*stepX + stepX/2 - CFG.lineThickness/2; const y = gy*stepY; const w = CFG.lineThickness; const h = stepY; const el=document.createElement('div'); el.className='line-vert'; el.style.left = x+'px'; el.style.top = y+'px'; el.style.width = w+'px'; el.style.height = h+'px'; arena.appendChild(el); state.lines.push({type:'wall',x,y,w,h,el});
      } else if(r<0.14){ // horizontal spike
        const x = gx*stepX; const y = gy*stepY + stepY/2 - CFG.lineThickness/2; const w = stepX; const h = CFG.lineThickness; const el=document.createElement('div'); el.className='line-horz'; el.style.left = x+'px'; el.style.top = y+'px'; el.style.width = w+'px'; el.style.height = h+'px'; arena.appendChild(el); state.lines.push({type:'spike',x,y,w,h,el});
      } } } }

// ===== EVENTS =====
function chooseEvent(){ if(Math.random() > CFG.eventChance) return null; const arr=['wind','blackhole','bounce']; return arr[Math.floor(Math.random()*arr.length)]; }
function startRoundEvent(){ state.event = chooseEvent(); if(state.event === 'wind'){ state.wind.x = (Math.random()*2-1) * CFG.windStrength * 1.5; state.wind.y = (Math.random()*2-1) * CFG.windStrength * 1.5; } else { state.wind.x = (Math.random()*2-1) * CFG.windStrength; state.wind.y = (Math.random()*2-1) * CFG.windStrength; } }

// ===== BALLOON creation & interactions =====
let currentPointer = null;
function createBall(x,y,price,autoDragging=true){ const id = state.nextId++; const el = document.createElement('div'); el.className='balloon'; el.dataset.id = id; el.style.left = (x - CFG.minR) + 'px'; el.style.top = (y - CFG.minR) + 'px'; el.style.width = (CFG.minR*2) + 'px'; el.style.height = (CFG.minR*2) + 'px'; el.style.background = `hsl(${Math.floor(Math.random()*360)} 90% 55%)`; const label = document.createElement('div'); label.className='label'; label.textContent = 'x1.00'; el.appendChild(label); arena.appendChild(el);
  const obj = { id, el, x, y, vx:0, vy:0, r:CFG.minR, price, state:'inflating', popping:false, dragging:!!autoDragging, lastPointer:null, recentVel:{x:0,y:0}, multiplier:1 };
  // pointer handlers for this balloon (allow dragging while inflating)
  let pid = null;
  function onDown(e){ if(obj.popping) return; el.setPointerCapture(e.pointerId); pid = e.pointerId; obj.dragging = true; obj.state='inflating'; obj.lastPointer={x:e.clientX,y:e.clientY,t:performance.now()}; currentPointer = pid; }
  function onMove(e){ if(pid !== e.pointerId) return; const rect = arena.getBoundingClientRect(); obj.x = clamp(e.clientX - rect.left, obj.r, rect.width - obj.r); obj.y = clamp(e.clientY - rect.top, obj.r, rect.height - obj.r); const now = performance.now(), dt = Math.max(6, now - (obj.lastPointer?.t || now)); const dx = e.clientX - (obj.lastPointer?.x || e.clientX), dy = e.clientY - (obj.lastPointer?.y || e.clientY); obj.recentVel = { x: dx/dt*1000, y: dy/dt*1000 }; obj.lastPointer = {x:e.clientX,y:e.clientY,t:now}; }
  function onUp(e){ if(pid !== e.pointerId) return; el.releasePointerCapture(e.pointerId); pid = null; obj.dragging = false; obj.state='idle'; obj.vx = obj.recentVel.x * 0.008; obj.vy = obj.recentVel.y * 0.008; currentPointer = null; }
  el.addEventListener('pointerdown', onDown); window.addEventListener('pointermove', onMove); window.addEventListener('pointerup', onUp);
  state.balloons.set(id, obj); return obj; }

// helper: check overlap with lines or other balloons
function circleRectOverlap(cx,cy,r,rx,ry,rw,rh){ const closestX = Math.max(rx, Math.min(cx, rx + rw)); const closestY = Math.max(ry, Math.min(cy, ry + rh)); const dx = cx - closestX, dy = cy - closestY; return (dx*dx + dy*dy) < (r*r); }
function overlapsAny(cx,cy,r,ignoreId=null){ // check lines
  for(const L of state.lines){ if(circleRectOverlap(cx,cy,r,L.x,L.y,L.w,L.h)) return true; }
  // check other balloons
  for(const b of state.balloons.values()){ if(b.id === ignoreId || b.popping) continue; const d = Math.hypot(b.x - cx, b.y - cy); if(d < b.r + r + 0.5) return true; }
  return false; }

function popBalloon(obj, reason=''){ if(obj.popping) return; obj.popping = true; obj.state='popped'; const burst=document.createElement('div'); burst.className='burst'; burst.style.left = obj.x + 'px'; burst.style.top = obj.y + 'px'; burst.style.width = (obj.r*2) + 'px'; burst.style.height = (obj.r*2) + 'px'; burst.style.background = 'radial-gradient(circle, rgba(255,255,255,0.9), rgba(255,255,255,0.1))'; burst.style.animation = 'burstAnim .45s cubic-bezier(.2,.8,.2,1) forwards'; arena.appendChild(burst); try{ obj.el.remove() }catch{} setTimeout(()=>{ try{ burst.remove() }catch{} },480); state.balloons.delete(obj.id); log(`Шар #${obj.id} лопнул ${reason?('('+reason+')'):''}`); }

// collision resolution
function resolveCircleCircle(A,B){ const dx = B.x - A.x, dy = B.y - A.y; const dist = Math.hypot(dx,dy); if(dist === 0) return; const overlap = A.r + B.r - dist; if(overlap <= 0) return; const nx = dx/dist, ny = dy/dist; const mA = Math.max(1, A.r*A.r), mB = Math.max(1, B.r*B.r); A.x -= nx * (overlap * (mB/(mA+mB))); A.y -= ny * (overlap * (mB/(mA+mB))); B.x += nx * (overlap * (mA/(mA+mB))); B.y += ny * (overlap * (mA/(mA+mB))); const rvx = B.vx - A.vx, rvy = B.vy - A.vy; const rel = rvx*nx + rvy*ny; if(rel > 0) return; const e = 0.92; const j = -(1+e)*rel / (1/mA + 1/mB); const jx = j*nx, jy = j*ny; A.vx -= jx/mA; A.vy -= jy/mA; B.vx += jx/mB; B.vy += jy/mB; }

function resolveCircleLine(ball, L, bounceFactor=1){ const closestX = clamp(ball.x, L.x, L.x + L.w); const closestY = clamp(ball.y, L.y, L.y + L.h); const dx = ball.x - closestX, dy = ball.y - closestY; const dist = Math.hypot(dx,dy); if(dist === 0) return false; if(dist < ball.r){ const overlap = ball.r - dist; const nx = dx/dist, ny = dy/dist; ball.x += nx*overlap; ball.y += ny*overlap; const vn = ball.vx*nx + ball.vy*ny; ball.vx -= (1.9*bounceFactor) * vn * nx; ball.vy -= (1.9*bounceFactor) * vn * ny; ball.vx *= 0.92; ball.vy *= 0.92; return true; } return false; }

// ===== PHYSICS LOOP =====
let lastTime = performance.now();
function loop(now){ const dt = Math.min(40, now - lastTime); lastTime = now; const sec = dt/1000;
  // phase timers
  if(state.phase === 'buy'){ state.buyTimer -= sec; if(state.buyTimer <= 0){ // auto move to placement
      if(state.purchasedSlots > 0) { enterPlacement(); } else { // no purchases -> restart buy
        state.buyTimer = CFG.buyPhaseSec; }
    } }
  if(state.phase === 'run'){ state.roundTimer -= sec; if(state.roundTimer <= 0){ // end round: payout surviving balloons
      for(const b of Array.from(state.balloons.values())){ if(!b.popping){ const payout = b.price * (b.multiplier || 1); state.balance += payout; log(`PAYOUT #${b.id} x${(b.multiplier||1).toFixed(2)} +${payout.toFixed(2)}`); try{ b.el.remove() }catch{} } }
      state.balloons.clear(); state.purchasedSlots = 0; state.placedCount = 0; state.event = null; state.wind = {x:0,y:0}; state.buyTimer = CFG.buyPhaseSec; state.roundTimer = CFG.roundSec; state.phase = 'buy'; generateLines(); save(); log('Раунд завершён. Возврат в фазу покупок.'); }
  }

  // physics update during place/run (we still update so placed balls move)
  const arr = Array.from(state.balloons.values());
  // inflation: increase radius for inflating balls if space
  for(const b of arr){ if(b.state === 'inflating'){ const desired = Math.min(CFG.maxR, b.r + CFG.inflatePerSec * sec); if(!overlapsAny(b.x, b.y, desired, b.id)) { b.r = desired; b.multiplier = 1 + Math.pow(1 + 0.012*b.r, 1.02) - 1; } }
  }
  // integrate velocities
  for(const b of arr){ if(b.popping) continue; if(!b.dragging){ // apply event forces
      if(state.event === 'blackhole'){ const cx = arena.clientWidth/2, cy = arena.clientHeight/2; const dx = cx - b.x, dy = cy - b.y; const d = Math.hypot(dx,dy) + 1; const pull = (120 / (d*d)) * sec * 100; b.vx += dx/d * pull; b.vy += dy/d * pull; }
      // wind
      b.vx += state.wind.x * sec * 0.16; b.vy += state.wind.y * sec * 0.16; b.x += b.vx * dt * 0.06; b.y += b.vy * dt * 0.06; }
    // bounds
    const W = arena.clientWidth, H = arena.clientHeight; if(b.x - b.r < 0){ b.x = b.r; b.vx = -b.vx * (state.event === 'bounce' ? CFG.bounce*1.4 : CFG.bounce); } if(b.x + b.r > W){ b.x = W - b.r; b.vx = -b.vx * (state.event === 'bounce' ? CFG.bounce*1.4 : CFG.bounce); } if(b.y - b.r < 0){ b.y = b.r; b.vy = -b.vy * (state.event === 'bounce' ? CFG.bounce*1.4 : CFG.bounce); } if(b.y + b.r > H){ b.y = H - b.r; b.vy = -b.vy * (state.event === 'bounce' ? CFG.bounce*1.4 : CFG.bounce); }
    b.vx *= Math.pow(CFG.friction, dt/16); b.vy *= Math.pow(CFG.friction, dt/16);
  }

  // collisions iterations
  for(let iter=0; iter<3; iter++){
    // ball-ball
    for(let i=0;i<arr.length;i++){ for(let j=i+1;j<arr.length;j++){ const A=arr[i], B=arr[j]; if(A.popping||B.popping) continue; resolveCircleCircle(A,B); }}
    // ball-line
    for(const b of arr){ if(b.popping) continue; for(const L of state.lines){ const collided = resolveCircleLine(b, L, state.event === 'bounce' ? 1.6 : 1); if(collided && L.type === 'spike'){ popBalloon(b, 'spike'); break; } } }
  }

  // apply DOM updates
  for(const b of arr){ if(b.popping) continue; b.el.style.width = (b.r*2) + 'px'; b.el.style.height = (b.r*2) + 'px'; b.el.style.left = (b.x - b.r) + 'px'; b.el.style.top = (b.y - b.r) + 'px'; b.el.querySelector('.label').textContent = `x${(b.multiplier||1).toFixed(2)}`; }

  uiUpdate(); requestAnimationFrame(loop);
}

function enterPlacement(){ state.phase = 'place'; state.placedCount = 0; state.roundTimer = CFG.roundSec; // players now can place purchased slots
  // generate fixed wind for upcoming round but event unknown until start
  state.wind = {x:0,y:0}; generateLines(); log('Фаза размещения: разместите купленные шары.'); uiUpdate(); }

function startRun(){ if(state.phase !== 'place') return; state.phase = 'run'; // set event and wind for round
  state.event = chooseEvent(); if(state.event === 'wind'){ state.wind.x = (Math.random()*2-1) * CFG.windStrength * 1.5; state.wind.y = (Math.random()*2-1) * CFG.windStrength * 1.5; } else { state.wind.x = (Math.random()*2-1) * CFG.windStrength; state.wind.y = (Math.random()*2-1) * CFG.windStrength; } state.roundTimer = CFG.roundSec; log('Раунд начат. Событие: ' + (state.event||'none')); uiUpdate(); }

// Purchase and UI handlers
buyBtn.addEventListener('click', ()=>{ if(state.phase !== 'buy') return; if(state.balance < CFG.price) { log('Недостаточно средств'); return; } state.balance -= CFG.price; state.purchasedSlots++; log('Куплен слот'); save(); uiUpdate(); toPlaceBtn.disabled = false; });

toPlaceBtn.addEventListener('click', ()=>{ if(state.phase !== 'buy') return; if(state.purchasedSlots === 0){ log('Нет купленных слотов'); return; } enterPlacement(); startBtn.disabled = false; uiUpdate(); });

startBtn.addEventListener('click', ()=>{ if(state.phase !== 'place') return; startRun(); startBtn.disabled = true; uiUpdate(); });

// Placement: clicking and holding creates and inflates balloon, consumes one purchased slot
arena.addEventListener('pointerdown', (e)=>{
  if(state.phase !== 'place') return; if(state.purchasedSlots <= 0) { log('Нет доступных слотов'); return; }
  const rect = arena.getBoundingClientRect(); const x = e.clientX - rect.left, y = e.clientY - rect.top;
  // check not overlapping
  if(overlapsAny(x,y, CFG.minR, null)){ log('Занято — выберите другое место'); return; }
  const b = createBall(x,y, CFG.price, true); state.purchasedSlots--; state.placedCount++; log('Размещен шар #' + b.id); uiUpdate(); });

// Prevent scroll
document.addEventListener('touchmove', function(e){ e.preventDefault(); }, {passive:false});

// init
generateLines(); uiUpdate(); save(); requestAnimationFrame(loop);

</script>
</body>
</html>