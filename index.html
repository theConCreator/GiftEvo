<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Balloon Arena</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
<style>
 body { margin:0; background:#0a0a0f; overflow:hidden; font-family:Arial; }
 #ui { position:fixed; top:0; left:0; width:100%; padding:10px; color:white; text-align:center; z-index:10; }
 #ui button { padding:10px 18px; border:none; border-radius:8px; background:#ff3c6a; color:white; font-size:16px; }
 #log { position:fixed; bottom:0; left:0; width:100%; max-height:120px; overflow-y:auto; color:white; padding:8px; background:rgba(0,0,0,0.4); font-size:14px; }
</style>
</head>
<body>
<div id="ui">
 <button id="claimBtn">Забрать</button>
 <span id="timer">40</span>s
</div>
<div id="log"></div>
<script>
const W = window.innerWidth;
const H = window.innerHeight;
let game, scene;
let balloons = [];
let obstacles = [];
let roundTime = 40;
let roundTimer = roundTime;
let currentBalloon = null;
let pointerDown = false;
let windForce = 0;

const log = (t)=>{ document.getElementById('log').innerHTML += t+"<br>"; };

document.getElementById("claimBtn").onclick = ()=>{
 if(currentBalloon){
  const x = (currentBalloon.radius/30).toFixed(2);
  log("Забрал x"+x);
  scene.removeBalloon(currentBalloon);
  currentBalloon = null;
 }
};

window.onload = ()=>{
 const config = {
  type: Phaser.AUTO,
  width: W,
  height: H,
  backgroundColor: '#101018',
  physics: { default: 'arcade', arcade:{ debug:false } },
  scene: { preload, create, update }
 };
 game = new Phaser.Game(config);
};

function preload(){ }

function create(){
 scene = this;
 roundStart();
 this.input.on('pointerdown', startBalloon);
 this.input.on('pointerup', ()=>{ pointerDown=false; });
 this.input.on('pointermove', dragBalloon);
}

function roundStart(){
 roundTimer = roundTime;
 obstacles.forEach(o=>o.destroy());
 obstacles = [];
 balloons.forEach(b=>b.sprite.destroy());
 balloons = [];
 generateObstacles();
 const t = setInterval(()=>{
  roundTimer--;
  document.getElementById('timer').innerText = roundTimer;
  if(roundTimer<=0){ clearInterval(t); roundEnd(); }
 },1000);
}

function roundEnd(){
 balloons.forEach(b=>{
  const x = (b.radius/30).toFixed(2);
  log("Раунд окончен. Ваш x"+x);
  b.sprite.destroy();
 });
 balloons = [];
 currentBalloon=null;
 roundStart();
}

function generateObstacles(){
 // walls
 const wall1 = scene.add.rectangle(W/2, 20, W*0.6, 20, 0x333344);
 const wall2 = scene.add.rectangle(W/2, H-20, W*0.6, 20, 0x333344);
 scene.physics.add.existing(wall1, true);
 scene.physics.add.existing(wall2, true);
 obstacles.push(wall1, wall2);

 // spikes
 for(let i=0;i<4;i++){
  let s = scene.add.triangle(
   Phaser.Math.Between(60,W-60),
   Phaser.Math.Between(60,H-60),
   0,40, 20,0, 40,40,
   0xff0033
  );
  scene.physics.add.existing(s, true);
  s.isSpike = true;
  obstacles.push(s);
 }

 // wind
 windForce = Phaser.Math.FloatBetween(-80,80);
 log("Ветер: " + windForce.toFixed(1));
}

function startBalloon(pointer){
 pointerDown = true;
 let x = pointer.x;
 let y = pointer.y;
 currentBalloon = createBalloon(x,y);
 balloons.push(currentBalloon);
}

function dragBalloon(pointer){
 if(pointerDown && currentBalloon && currentBalloon.radius<35){
  currentBalloon.sprite.x = pointer.x;
  currentBalloon.sprite.y = pointer.y;
 }
}

function createBalloon(x,y){
 let g = scene.add.circle(x,y,20,0x44aaff);
 scene.physics.add.existing(g);
 g.body.setCircle(20);
 g.body.setBounce(0.8);
 g.body.setCollideWorldBounds(true);
 obstacles.forEach(o=>scene.physics.add.collider(g,o));
 return { sprite:g, radius:20 };
}

function update(time,delta){
 balloons.forEach(b=>{
  b.sprite.body.velocity.x += windForce * 0.01;
 });

 if(pointerDown && currentBalloon){ inflateBalloon(currentBalloon); }

 // collisions between balloons
 for(let i=0;i<balloons.length;i++){
  for(let j=i+1;j<balloons.length;j++){
   scene.physics.world.collide(balloons[i].sprite, balloons[j].sprite);
  }
 }
}

function inflateBalloon(b){
 if(b.radius>120) return explode(b);

 let newR = b.radius + 0.35;
 if(!canExpand(b, newR)) return;

 b.radius = newR;
 b.sprite.setRadius(newR);
 b.sprite.body.setCircle(newR);
 b.sprite.body.mass = newR/10;

 if(Math.random()< (b.radius/2000)) explode(b);
}

function canExpand(balloon, newR){
 // check overlap with obstacles
 for(let o of obstacles){
  let dx = balloon.sprite.x - o.x;
  let dy = balloon.sprite.y - o.y;
  let dist = Math.sqrt(dx*dx+dy*dy);
  if(dist < newR + 40 && o.width){ return false; }
  if(o.isSpike && dist < newR + 30){ explode(balloon); return false; }
 }
 return true;
}

function explode(b){
 let x = b.sprite.x, y = b.sprite.y;
 let p = scene.add.particles("");
 let emitter = p.createEmitter({
  x, y,
  speed: {min:-200,max:200},
  scale: {start:0.5,end:0},
  lifespan:600,
  tint:0xff3355
 });
 setTimeout(()=>p.destroy(),600);
 log("Шар лопнул! x"+(b.radius/30).toFixed(2));
 scene.removeBalloon(b);
}

Phaser.Scene.prototype.removeBalloon = function(b){
 let idx = balloons.indexOf(b);
 if(idx>=0) balloons.splice(idx,1);
 b.sprite.destroy();
};
</script>
</body>
</html>
